<!-- _includes/glsl-widget.html -->
{% assign widget_id = include.id | default: "glsl-widget-default" %}
{% assign width = include.width | default: "500" %}
{% assign height = include.height | default: "300" %}

{% capture default_shader %}
// Default fragment shader
precision mediump float;

uniform float time;
uniform vec2 resolution;

void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    
    // Simple color gradient based on position and time
    vec3 color = vec3(
        0.5 + 0.5 * sin(time + uv.x * 6.0),
        0.5 + 0.5 * sin(time + uv.y * 6.0),
        0.5 + 0.5 * sin(time + (uv.x + uv.y) * 6.0)
    );
    
    gl_FragColor = vec4(color, 1.0);
}
{% endcapture %}

{% assign initial_code = include.code | default: default_shader %}

<div class="glsl-widget" data-widget-id="{{ widget_id }}">
  <div class="glsl-canvas-container">
    <canvas class="glsl-canvas" width="{{ width }}" height="{{ height }}"></canvas>
    <div class="glsl-error" style="display: none; color: red; padding: 10px; background: #ffeeee; margin-top: 10px; border: 1px solid #ffcccc;"></div>
    <div class="glsl-status" style="color: #666; font-size: 12px; margin-top: 5px; text-align: right;"></div>
  </div>
  
  <div class="glsl-editor-container">
    <textarea class="glsl-editor">{{ initial_code }}</textarea>
  </div>
  
  <div class="glsl-controls">
    <button class="glsl-run">Run Shader</button>
    <button class="glsl-reset">Reset</button>
    <button class="glsl-debug">Debug Info</button>
  </div>
</div>

{% capture widget_styles %}
<style>
  .glsl-widget {
    margin: 20px 0;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: #f8f8f8;
  }
  
  .glsl-canvas {
    width: 100%;
    max-width: 100%;
    height: auto;
    background-color: #000;
    border: 1px solid #333;
  }
  
  .glsl-editor {
    width: 100%;
    height: 250px;
    margin-top: 10px;
    font-family: monospace;
    font-size: 14px;
    padding: 10px;
    border: 1px solid #ccc;
    resize: vertical;
  }
  
  .glsl-controls {
    margin-top: 10px;
  }
  
  .glsl-controls button {
    margin-right: 10px;
    padding: 5px 10px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  
  .glsl-controls button:hover {
    background-color: #45a049;
  }
</style>
{% endcapture %}

{% capture widget_script %}
<script>
  // Initialize all GLSL widgets on the page
  document.addEventListener('DOMContentLoaded', function() {
    console.log("GLSL Widgets: Initializing...");
    document.querySelectorAll('.glsl-widget').forEach(initWidget);
  });
  
  function initWidget(widgetElement) {
    // Get widget ID
    const widgetId = widgetElement.getAttribute('data-widget-id');
    console.log("GLSL Widget: Initializing widget with ID:", widgetId);
    
    // Get the elements
    const canvas = widgetElement.querySelector('.glsl-canvas');
    const editor = widgetElement.querySelector('.glsl-editor');
    const runButton = widgetElement.querySelector('.glsl-run');
    const resetButton = widgetElement.querySelector('.glsl-reset');
    const debugButton = widgetElement.querySelector('.glsl-debug');
    const errorElement = widgetElement.querySelector('.glsl-error');
    const statusElement = widgetElement.querySelector('.glsl-status');
    
    // Store the initial code
    const initialCode = editor.value;
    
    // Set up WebGL
    let gl = null;
    let program = null;
    let startTime = Date.now();
    let isRunning = false;
    let animationFrameId = null;
    
    // Display error
    function showError(message) {
      errorElement.innerHTML = message;
      errorElement.style.display = 'block';
      console.error(`GLSL Widget [${widgetId}] Error:`, message);
    }
    
    // Clear error
    function clearError() {
      errorElement.innerHTML = '';
      errorElement.style.display = 'none';
    }
    
    // Update status
    function updateStatus(message) {
      statusElement.innerHTML = message;
      console.log(`GLSL Widget [${widgetId}] Status:`, message);
    }
    
    // Initialize WebGL
    function initGL() {
      clearError();
      
      // Try to get WebGL context
      try {
        gl = canvas.getContext('webgl', { preserveDrawingBuffer: true }) || 
             canvas.getContext('experimental-webgl', { preserveDrawingBuffer: true });
      } catch (e) {
        showError(`WebGL error: ${e.message}`);
        return false;
      }
      
      if (!gl) {
        showError('Unable to initialize WebGL. Your browser may not support it.');
        return false;
      }
      
      // Check if context is valid
      if (gl.isContextLost()) {
        showError('WebGL context is lost.');
        return false;
      }
      
      updateStatus('WebGL initialized successfully');
      return true;
    }
    
    // Show debug info
    function showDebugInfo() {
      if (!gl) {
        showError('WebGL not initialized');
        return;
      }
      
      const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
      let info = 'WebGL Debug Info:\n';
      
      if (debugInfo) {
        info += `Vendor: ${gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL)}\n`;
        info += `Renderer: ${gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)}\n`;
      }
      
      info += `WebGL Version: ${gl.getParameter(gl.VERSION)}\n`;
      info += `Shader Version: ${gl.getParameter(gl.SHADING_LANGUAGE_VERSION)}\n`;
      info += `Canvas Size: ${canvas.width}x${canvas.height}`;
      
      alert(info);
      console.log(info);
    }
    
    // Compile fragment shader and link program
    function compileAndLink(fragmentShaderSource) {
      if (!gl) return false;
      
      clearError();
      
      // If there's an existing program, delete it
      if (program) {
        gl.deleteProgram(program);
        program = null;
      }
      
      // Create a new program
      program = gl.createProgram();
      
      // Create and compile fragment shader
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fragmentShaderSource);
      gl.compileShader(fragmentShader);
      
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        const error = gl.getShaderInfoLog(fragmentShader);
        showError(`Fragment shader compilation error: ${error}`);
        return false;
      }
      
      // Create vertex shader
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const vertexShaderSource = `
        attribute vec2 position;
        
        void main() {
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `;
      
      // Compile vertex shader
      gl.shaderSource(vertexShader, vertexShaderSource);
      gl.compileShader(vertexShader);
      
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        const error = gl.getShaderInfoLog(vertexShader);
        showError(`Vertex shader compilation error: ${error}`);
        return false;
      }
      
      // Attach shaders to program
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      
      // Link program
      gl.linkProgram(program);
      
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const error = gl.getProgramInfoLog(program);
        showError(`Program linking error: ${error}`);
        return false;
      }
      
      // Create a full-screen quad
      const vertices = new Float32Array([
        -1.0, -1.0,
         1.0, -1.0,
        -1.0,  1.0,
         1.0,  1.0
      ]);
      
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      
      // Set up attribute
      const positionLocation = gl.getAttribLocation(program, 'position');
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      
      updateStatus('Shader compiled successfully');
      return true;
    }
    
    // Render the shader
    function render() {
      if (!gl || !program) return;
      
      try {
        // Use the program
        gl.useProgram(program);
        
        // Set the viewport
        gl.viewport(0, 0, canvas.width, canvas.height);
        
        // Clear the canvas
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        // Set uniforms
        const timeLocation = gl.getUniformLocation(program, 'time');
        const resolutionLocation = gl.getUniformLocation(program, 'resolution');
        
        const currentTime = (Date.now() - startTime) / 1000.0;
        
        if (timeLocation !== null) {
          gl.uniform1f(timeLocation, currentTime);
        }
        
        if (resolutionLocation !== null) {
          gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
        }
        
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        
        // Request next frame
        if (isRunning) {
          animationFrameId = requestAnimationFrame(render);
        }
      } catch (e) {
        stopAnimation();
        showError(`Render error: ${e.message}`);
      }
    }
    
    // Start the animation
    function startAnimation() {
      if (!isRunning) {
        isRunning = true;
        startTime = Date.now();
        updateStatus('Animation started');
        render();
      }
    }
    
    // Stop the animation
    function stopAnimation() {
      isRunning = false;
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        updateStatus('Animation stopped');
      }
    }
    
    // Run the shader
    function runShader() {
      stopAnimation();
      clearError();
      
      try {
        if (compileAndLink(editor.value)) {
          startAnimation();
        }
      } catch (e) {
        showError(`Error running shader: ${e.message}`);
      }
    }
    
    // Reset the shader
    function resetShader() {
      editor.value = initialCode;
      runShader();
    }
    
    // Initialize the widget
    try {
      if (initGL()) {
        // Set up event listeners
        runButton.addEventListener('click', runShader);
        resetButton.addEventListener('click', resetShader);
        debugButton.addEventListener('click', showDebugInfo);
        
        // Run the shader
        runShader();
      }
    } catch (e) {
      showError(`Widget initialization error: ${e.message}`);
    }
  }
</script>
{% endcapture %}

<!-- Only include styles once per page -->
{% if glsl_widget_styles_loaded != true %}
  {{ widget_styles }}
  {% assign glsl_widget_styles_loaded = true %}
{% endif %}

<!-- Only include script once per page -->
{% if glsl_widget_script_loaded != true %}
  {{ widget_script }}
  {% assign glsl_widget_script_loaded = true %}
{% endif %}